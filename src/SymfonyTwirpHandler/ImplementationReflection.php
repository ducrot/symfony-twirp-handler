<?php


namespace SymfonyTwirpHandler;


use Google\Protobuf\Internal\Message;
use OutOfBoundsException;

class ImplementationReflection
{


    /**
     * @param string $serviceInterface The protobuf service interface generated by protoc with option php_generic_services = true
     * @param object $serviceImplementation The implementation of the service
     * @return ImplementationReflection
     */
    public static function create(string $serviceInterface, $serviceImplementation): self
    {
        $interface = InterfaceReflection::create($serviceInterface);
        return new ImplementationReflection($interface, $serviceImplementation);
    }


    /** @var InterfaceReflection */
    private $interface;

    /** @var object */
    private $implementation;

    /**
     * Holds already built methods by name.
     * @var ImplementationMethodReflection[]
     */
    private $methodCache;


    /**
     * ServiceInvoke constructor.
     * @param InterfaceReflection $interface
     * @param object $implementation The instance implementing the service interface
     */
    public function __construct(InterfaceReflection $interface, $implementation)
    {
        $interface->validateImplementation($implementation);
        $this->interface = $interface;
        $this->implementation = $implementation;
        $this->methodCache = [];
    }


    public function invoke($methodName, Message $parameter, bool $caseSensitive = false): Message
    {
        $method = $this->findMethod($methodName, $caseSensitive);
        if (!$method) {
            $msg = sprintf('Method "%s" of service %s not found.', $methodName, $this->interface->getName());
            throw new OutOfBoundsException($msg);
        }
        return $method->invoke($parameter);
    }


    /**
     * @return ImplementationMethodReflection[]
     */
    public function getMethods(): array
    {
        $a = [];
        foreach ($this->interface->getMethods() as $reflectionMethod) {
            $a[] = $this->buildMethod($reflectionMethod);
        }
        return $a;
    }


    public function findMethod(string $name, bool $caseSensitive = false): ?ImplementationMethodReflection
    {
        $reflectionMethod = $this->interface->findMethod($name, $caseSensitive);
        if (!$reflectionMethod) {
            return null;
        }
        return $this->buildMethod($reflectionMethod);
    }


    private function buildMethod(InterfaceMethodReflection $refMethod): ImplementationMethodReflection
    {
        if (!array_key_exists($refMethod->getName(), $this->methodCache)) {
            $this->methodCache[$refMethod->getName()] = new ImplementationMethodReflection($refMethod, $this->implementation);
        }
        return $this->methodCache[$refMethod->getName()];
    }


    public function getName(): string
    {
        return get_class($this->implementation);
    }


    public function getInterface(): string
    {
        return $this->interface->getName();
    }


}
