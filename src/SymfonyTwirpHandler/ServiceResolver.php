<?php


namespace SymfonyTwirpHandler;


use Generator;
use LogicException;
use Psr\Container\ContainerInterface;
use Throwable;
use UnexpectedValueException;

class ServiceResolver
{


    /** @var string[] */
    private $serviceInterfaces;

    /** @var InterfaceReflection[] */
    private $refByInterface;

    /** @var object[] */
    private $impByInterface;

    /** @var callable[] */
    private $impFactoryByInterface;

    /** @var ContainerInterface[] */
    private $impContainerByInterface;


    public function __construct()
    {
        $this->serviceInterfaces = [];
        $this->refByInterface = [];
        $this->impByInterface = [];
        $this->impFactoryByInterface = [];
        $this->impContainerByInterface = [];
    }


    /**
     * @param string $serviceInterface The protobuf service interface generated by protoc with option php_generic_services = true
     * @param callable $serviceImplementation
     */
    public function registerFactory(string $serviceInterface, callable $serviceImplementation): void
    {
        $this->registerInterface($serviceInterface);
        $this->impFactoryByInterface[$serviceInterface] = $serviceImplementation;
    }


    /**
     * @param string $serviceInterface The protobuf service interface generated by protoc with option php_generic_services = true
     * @param object $serviceImplementation
     */
    public function registerInstance(string $serviceInterface, $serviceImplementation): void
    {
        if (!is_object($serviceImplementation)) {
            $msg = sprintf('Expected object, got %s.', gettype($serviceImplementation));
            throw new UnexpectedValueException($msg);
        }
        $this->registerInterface($serviceInterface);
        $this->impByInterface[$serviceInterface] = $serviceImplementation;
    }


    /**
     * @param string $serviceInterface The protobuf service interface generated by protoc with option php_generic_services = true
     * @param ContainerInterface $container
     */
    public function registerContainer(string $serviceInterface, ContainerInterface $container): void
    {
        $this->registerInterface($serviceInterface);
        $this->impContainerByInterface[$serviceInterface] = $container;
    }


    public function validate(): void
    {
        foreach ($this->findInterfaces() as $ir) {
            $imp = $this->resolveImplementation($ir->getName());
            $ir->validateImplementation($imp);
        }
    }


    public function findService(string $serviceName, $caseSensitive = false): ?ImplementationReflection
    {
        foreach ($this->findInterfaces($serviceName, $caseSensitive) as $ir) {
            $imp = $this->resolveImplementation($ir->getName());
            return new ImplementationReflection($ir, $imp);
        }
        return null;
    }


    /**
     * @return ImplementationReflection[]
     */
    public function getServices(): array
    {
        $a = [];
        foreach ($this->findInterfaces() as $ir) {
            $imp = $this->resolveImplementation($ir->getName());
            $a[] = new ImplementationReflection($ir, $imp);
        }
        return $a;
    }


    private function registerInterface(string $serviceInterface): void
    {
        if (in_array($serviceInterface, $this->serviceInterfaces)) {
            $msg = sprintf('Service interface %s is already registered.', $serviceInterface);
            throw new UnexpectedValueException($msg);
        }
        $this->serviceInterfaces[] = $serviceInterface;
    }


    /**
     * @param string $serviceName
     * @param bool $caseSensitive
     * @return Generator|InterfaceReflection[]
     */
    private function findInterfaces(string $serviceName = null, bool $caseSensitive = false): Generator
    {
        foreach ($this->serviceInterfaces as $serviceInterface) {
            if (!array_key_exists($serviceInterface, $this->refByInterface)) {
                $this->refByInterface[$serviceInterface] = InterfaceReflection::create($serviceInterface);
            }
            $ir = $this->refByInterface[$serviceInterface];
            if (is_string($serviceName)) {
                $e = $serviceName;
                $a = $ir->getProtobufType();
                if (!$caseSensitive) {
                    $e = strtolower($e);
                    $a = strtolower($a);
                }
                if ($a !== $e) {
                    continue;
                }
            }
            yield $ir;
        }
    }


    /**
     * @param string $serviceInterface
     * @return object
     */
    private function resolveImplementation(string $serviceInterface)
    {
        if (array_key_exists($serviceInterface, $this->impByInterface)) {
            return $this->impByInterface[$serviceInterface];
        }
        if (array_key_exists($serviceInterface, $this->impFactoryByInterface)) {
            $factory = $this->impFactoryByInterface[$serviceInterface];
            try {
                $imp = $factory();
            } catch (Throwable $throwable) {
                $msg = sprintf('Error invoking factory for service implementation for interface %s: %s', $serviceInterface, $throwable->getMessage());
                throw new LogicException($msg, 0, $throwable);
            }
            if (!is_object($imp)) {
                $msg = sprintf('Error invoking factory for service implementation for interface %s: Expected object, got %s.', $serviceInterface, gettype($imp));
                throw new LogicException($msg);
            }
            return $imp;
        }
        if (array_key_exists($serviceInterface, $this->impContainerByInterface)) {
            $container = $this->impContainerByInterface[$serviceInterface];
            $imp = $container->get($serviceInterface);
            if (!is_object($imp)) {
                $msg = sprintf('Error getting service implementation for interface %s from container: Expected object, got %s.', $serviceInterface, gettype($imp));
                throw new LogicException($msg);
            }
        }
        throw new LogicException();
    }


}
